name: Auto-update SUMMARY.md

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - '!src/SUMMARY.md'
  workflow_dispatch:

jobs:
  update-summary:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate SUMMARY.md
        run: |
          cat > generate-summary.py << 'SCRIPT_END'
          import os
          from pathlib import Path
          import re
          
          def get_title(filepath):
              """Extract title from markdown file's first # heading"""
              try:
                  with open(filepath, 'r', encoding='utf-8') as f:
                      content = f.read()
                      match = re.search(r'^#\s+(.+)$', content, re.MULTILINE)
                      if match:
                          return match.group(1).strip()
              except:
                  pass
              # Fallback to filename
              name = Path(filepath).stem
              if name.lower() == 'readme':
                  # For README files, use parent directory name
                  return Path(filepath).parent.name.replace('-', ' ').replace('_', ' ').title()
              return name.replace('-', ' ').replace('_', ' ').title()
          
          def scan_directory(dir_path, base_path):
              """Scan a directory and return its structure"""
              items = {
                  'readme': None,
                  'files': [],
                  'subdirs': {}
              }
              
              for entry in sorted(os.listdir(dir_path)):
                  if entry.startswith('.') or entry == 'SUMMARY.md':
                      continue
                      
                  full_path = Path(dir_path) / entry
                  rel_path = full_path.relative_to(base_path)
                  
                  if full_path.is_file() and entry.endswith('.md'):
                      if entry.lower() == 'readme.md':
                          items['readme'] = {
                              'title': get_title(full_path),
                              'path': str(rel_path)
                          }
                      else:
                          items['files'].append({
                              'title': get_title(full_path),
                              'path': str(rel_path)
                          })
                  elif full_path.is_dir():
                      subdir_items = scan_directory(full_path, base_path)
                      # Only include subdirs that have content
                      if subdir_items['readme'] or subdir_items['files'] or subdir_items['subdirs']:
                          items['subdirs'][entry] = subdir_items
              
              return items
          
          def render_items(items, indent=0):
              """Render items with proper mdBook indentation"""
              lines = []
              indent_str = '    ' * indent  # 4 spaces per level
              
              # Process files at current level
              for file_info in items['files']:
                  lines.append(f"{indent_str}- [{file_info['title']}](./{file_info['path']})\n")
              
              # Process subdirectories
              for dirname, subitems in sorted(items['subdirs'].items()):
                  if subitems['readme']:
                      # Directory has README - use it as parent
                      lines.append(f"{indent_str}- [{subitems['readme']['title']}](./{subitems['readme']['path']})\n")
                      # Render children with extra indent
                      lines.extend(render_items(subitems, indent + 1))
                  else:
                      # No README - use directory name as non-clickable parent
                      dir_title = dirname.replace('-', ' ').replace('_', ' ').title()
                      lines.append(f"{indent_str}- {dir_title}\n")
                      # Render children with extra indent
                      lines.extend(render_items(subitems, indent + 1))
              
              return lines
          
          def generate_summary():
              """Generate the complete SUMMARY.md"""
              base_path = Path('src')
              structure = scan_directory(base_path, base_path)
              
              lines = ["# Summary\n\n"]
              
              # Root README becomes Introduction
              if structure['readme']:
                  lines.append(f"[Introduction](./{structure['readme']['path']})\n\n")
              
              # Root-level files
              for file_info in structure['files']:
                  lines.append(f"- [{file_info['title']}](./{file_info['path']})\n")
              
              # Root-level directories
              for dirname, items in sorted(structure['subdirs'].items()):
                  if items['readme']:
                      # Has README - use as clickable parent
                      lines.append(f"- [{items['readme']['title']}](./{items['readme']['path']})\n")
                      lines.extend(render_items(items, 1))
                  else:
                      # No README - use directory name as section
                      dir_title = dirname.replace('-', ' ').replace('_', ' ').title()
                      lines.append(f"- {dir_title}\n")
                      lines.extend(render_items(items, 1))
              
              return ''.join(lines)
          
          # Generate and write
          summary_content = generate_summary()
          
          # Preserve manual sections if they exist
          summary_path = Path('src/SUMMARY.md')
          if summary_path.exists():
              with open(summary_path, 'r', encoding='utf-8') as f:
                  existing = f.read()
                  if '<!-- manual -->' in existing:
                      manual_section = existing.split('<!-- manual -->')[1]
                      summary_content += '\n<!-- manual -->' + manual_section
          
          with open(summary_path, 'w', encoding='utf-8') as f:
              f.write(summary_content)
          
          print("SUMMARY.md generated successfully!")
          print("\nGenerated structure preview:")
          print(summary_content[:500] + "..." if len(summary_content) > 500 else summary_content)
          SCRIPT_END
          
          python generate-summary.py
      
      - name: Check for changes
        id: verify
        run: |
          if [[ -n $(git status -s src/SUMMARY.md) ]]; then
            echo "changes=true" >> $GITHUB_OUTPUT
          else
            echo "changes=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Commit and push
        if: steps.verify.outputs.changes == 'true'
        run: |
          git config user.name github-actions[bot]
          git config user.email github-actions[bot]@users.noreply.github.com
          git add src/SUMMARY.md
          git commit -m "Auto-update SUMMARY.md"
          git push
